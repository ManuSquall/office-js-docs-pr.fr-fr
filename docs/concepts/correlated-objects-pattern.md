---
title: Éviter d’utiliser la méthode context.sync dans des boucles
description: Découvrez comment utiliser les modèles de boucle de fractionnement et d’objets corrélés pour éviter d’appeler Context. Sync dans une boucle.
ms.date: 04/09/2020
localization_priority: Normal
ms.openlocfilehash: bdb7340b999d74baf200aafda2d0f2f41420bd14
ms.sourcegitcommit: be23b68eb661015508797333915b44381dd29bdb
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/08/2020
ms.locfileid: "44608033"
---
# <a name="avoid-using-the-contextsync-method-in-loops"></a><span data-ttu-id="46fe6-103">Éviter d’utiliser la méthode context.sync dans des boucles</span><span class="sxs-lookup"><span data-stu-id="46fe6-103">Avoid using the context.sync method in loops</span></span>

> [!NOTE]
> <span data-ttu-id="46fe6-104">Cet article suppose que vous êtes au-delà de la phase de démarrage de l’utilisation d’au moins l’une des quatre API JavaScript &mdash; pour Excel, Word, OneNote et Visio &mdash; qui utilisent un système de traitement par lots pour interagir avec le document Office.</span><span class="sxs-lookup"><span data-stu-id="46fe6-104">This article assumes that you're beyond the beginning stage of working with at least one of the four host-specific Office JavaScript APIs&mdash;for Excel, Word, OneNote, and Visio&mdash;that use a batch system to interact with the Office document.</span></span> <span data-ttu-id="46fe6-105">En particulier, vous devez savoir ce qu’est un appel de `context.sync` et savoir ce qu’est un objet de la collection.</span><span class="sxs-lookup"><span data-stu-id="46fe6-105">In particular, you should know what a call of `context.sync` does and you should know what a collection object is.</span></span> <span data-ttu-id="46fe6-106">Si vous n’êtes pas à ce stade, commencez par [comprendre l’API JavaScript pour Office](../develop/understanding-the-javascript-api-for-office.md) et la documentation liée à la section « propre à l’hôte » de cet article.</span><span class="sxs-lookup"><span data-stu-id="46fe6-106">If you're not at that stage, please start with [Understanding the Office JavaScript API](../develop/understanding-the-javascript-api-for-office.md) and the documentation linked to under "host-specific" in that article.</span></span>

<span data-ttu-id="46fe6-107">Pour certains scénarios de programmation dans les compléments Office qui utilisent l’un des modèles d’API propres à l’hôte (pour Excel, Word, OneNote et Visio), votre code doit lire, écrire ou traiter certaines propriétés à partir de chaque membre d’un objet de collection.</span><span class="sxs-lookup"><span data-stu-id="46fe6-107">For some programming scenarios in Office Add-ins that use one of the host-specific API models (for Excel, Word, OneNote, and Visio), your code needs to read, write, or process some property from every member of a collection object.</span></span> <span data-ttu-id="46fe6-108">Par exemple, un complément Excel qui doit obtenir les valeurs de chaque cellule d’une colonne de table particulière ou d’un complément Word qui doit mettre en surbrillance chaque instance d’une chaîne dans le document.</span><span class="sxs-lookup"><span data-stu-id="46fe6-108">For example, an Excel add-in that needs to get the values of every cell in a particular table column or a Word add-in that needs to highlight every instance of a string in the document.</span></span> <span data-ttu-id="46fe6-109">Vous devez effectuer une itération sur les membres dans la `items` propriété de l’objet de collection ; Toutefois, pour des raisons de performances, vous devez éviter d’appeler `context.sync` dans chaque itération de la boucle.</span><span class="sxs-lookup"><span data-stu-id="46fe6-109">You need to iterate over the members in the `items` property of the collection object; but, for performance reasons, you need to avoid calling `context.sync` in every iteration of the loop.</span></span> <span data-ttu-id="46fe6-110">Chaque appel de `context.sync` est un aller-retour entre le complément et le document Office.</span><span class="sxs-lookup"><span data-stu-id="46fe6-110">Every call of `context.sync` is a round trip from the add-in to the Office document.</span></span> <span data-ttu-id="46fe6-111">Les allers-retours répétés ont un impact sur les performances, en particulier si le complément est exécuté dans Office sur le Web, car les allers-retours sont effectués sur Internet.</span><span class="sxs-lookup"><span data-stu-id="46fe6-111">Repeated round trips hurt performance, especially if the add-in is running in Office on the web because the round trips go across the internet.</span></span>

> [!NOTE]
> <span data-ttu-id="46fe6-112">Tous les exemples de cet article utilisent `for` des boucles, mais les pratiques décrites s’appliquent à toutes les instructions Loop qui peuvent parcourir un tableau, notamment les suivantes :</span><span class="sxs-lookup"><span data-stu-id="46fe6-112">All examples in this article use `for` loops but the practices described apply to any loop statement that can iterate through an array, including the following:</span></span>
>
> - `for`
> - `for of`
> - `while`
> - `do while`
> 
> <span data-ttu-id="46fe6-113">Elles s’appliquent également à toute méthode Array à laquelle une fonction est passée et appliquée aux éléments du tableau, notamment les suivantes :</span><span class="sxs-lookup"><span data-stu-id="46fe6-113">They also apply to any array method to which a function is passed and applied to the items in the array, including the following:</span></span>
>
> - `Array.every`
> - `Array.forEach`
> - `Array.filter`
> - `Array.find`
> - `Array.findIndex`
> - `Array.map`
> - `Array.reduce`
> - `Array.reduceRight`
> - `Array.some`

## <a name="writing-to-the-document"></a><span data-ttu-id="46fe6-114">Écriture dans le document</span><span class="sxs-lookup"><span data-stu-id="46fe6-114">Writing to the document</span></span>

<span data-ttu-id="46fe6-115">Dans le cas le plus simple, vous écrivez uniquement aux membres d’un objet de collection, et non à la lecture de leurs propriétés.</span><span class="sxs-lookup"><span data-stu-id="46fe6-115">In the simplest case, you are only writing to members of a collection object, not reading their properties.</span></span> <span data-ttu-id="46fe6-116">Par exemple, le code suivant met en évidence en jaune toutes les occurrences de « The » dans un document Word.</span><span class="sxs-lookup"><span data-stu-id="46fe6-116">For example, the following code highlights in yellow every instance of "the" in a Word document.</span></span> 

> [!NOTE]
> <span data-ttu-id="46fe6-117">Il est généralement recommandé de placer un final `context.sync` juste avant le caractère « } » de la `run` méthode hôte (par exemple `Excel.run` , `Word.run` , etc.).</span><span class="sxs-lookup"><span data-stu-id="46fe6-117">It is generally a good practice to put have a final `context.sync` just before the closing "}" character of the host `run` method (such as `Excel.run`, `Word.run`, etc.).</span></span> <span data-ttu-id="46fe6-118">Cela est dû au fait que la `run` méthode effectue un appel masqué de `context.sync` la dernière chose qu’elle effectue si, et seulement si, il existe des commandes en file d’attente qui n’ont pas encore été synchronisées.</span><span class="sxs-lookup"><span data-stu-id="46fe6-118">This is because the `run` method makes a hidden call of `context.sync` as the last thing it does if, and only if, there are queued commands that have not yet been synchronized.</span></span> <span data-ttu-id="46fe6-119">Le fait que cet appel soit masqué peut prêter à confusion, c’est pourquoi nous vous recommandons généralement d’ajouter le explicite `context.sync` .</span><span class="sxs-lookup"><span data-stu-id="46fe6-119">The fact that this call is hidden can be confusing, so we generally recommend that you add the explicit `context.sync`.</span></span> <span data-ttu-id="46fe6-120">Toutefois, étant donné que cet article concerne la réduction des appels de `context.sync` , il est en fait plus déroutant d’ajouter une final entièrement inutile `context.sync` .</span><span class="sxs-lookup"><span data-stu-id="46fe6-120">However, given that this article is about minimizing calls of `context.sync`, it is actually more confusing to add an entirely unnecessary final `context.sync`.</span></span> <span data-ttu-id="46fe6-121">Par conséquent, dans cet article, nous les laissons quand il n’y a pas de commandes non synchronisées à la fin du `run` .</span><span class="sxs-lookup"><span data-stu-id="46fe6-121">So, in this article, we leave it out when there are no unsynchronized commands at the end of the `run`.</span></span> 

```javascript
Word.run(async function (context) {
    let startTime, endTime;
    const docBody = context.document.body;

    // search() returns an array of Ranges.
    const searchResults = docBody.search('the', { matchWholeWord: true });
    context.load(searchResults, 'items');
    await context.sync();

    // Record the system time.
    startTime = performance.now();

    for (var i = 0; i < searchResults.items.length; i++) {
      searchResults.items[i].font.highlightColor = '#FFFF00';

      await context.sync(); // SYNCHRONIZE IN EACH ITERATION
    }
    
    // await context.sync(); // SYNCHRONIZE AFTER THE LOOP

    // Record the system time again then calculate how long the operation took.
    endTime = performance.now();
    console.log("The operation took: " + (endTime - startTime) + " milliseconds.");
  })
}
```

<span data-ttu-id="46fe6-122">Le code précédent prenait une seconde complète dans un document avec 200 instances de « The » dans Word sur Windows.</span><span class="sxs-lookup"><span data-stu-id="46fe6-122">The preceding code took 1 full second to complete in a document with 200 instances of "the" in Word on Windows.</span></span> <span data-ttu-id="46fe6-123">Toutefois, lorsque la `await context.sync();` ligne à l’intérieur de la boucle est commentée et que la même ligne juste après le commentaire de la boucle, l’opération a duré seulement 1/10 de seconde.</span><span class="sxs-lookup"><span data-stu-id="46fe6-123">But when the `await context.sync();` line inside the loop is commented out and the same line just after the loop is uncommented, the operation took only a 1/10th of a second.</span></span> <span data-ttu-id="46fe6-124">Dans Word sur le Web (avec le serveur Edge en tant que navigateur), la synchronisation à l’intérieur de la boucle a duré 3 secondes, et seulement 6/10 à la synchronisation après la boucle, environ cinq fois plus vite.</span><span class="sxs-lookup"><span data-stu-id="46fe6-124">In Word on the web (with Edge as the browser), it took 3 full seconds with the synchronization inside the loop and only 6/10ths of a second with the synchronization after the loop, about five times faster.</span></span> <span data-ttu-id="46fe6-125">Dans un document avec 2000 instances de "The", il a fallu (dans Word sur le Web) 80 secondes avec la synchronisation à l’intérieur de la boucle et seulement 4 secondes avec la synchronisation après la boucle, environ 20 fois plus rapide.</span><span class="sxs-lookup"><span data-stu-id="46fe6-125">In a document with 2000 instances of "the", it took (in Word on the web) 80 seconds with the synchronization inside the loop and only 4 seconds with the synchronization after the loop, about 20 times faster.</span></span>

> [!NOTE]
> <span data-ttu-id="46fe6-126">Il est utile de demander si la version synchronisée à l’intérieur de la boucle s’exécute plus rapidement si les synchronisations ont été exécutées simultanément, ce qui peut être effectué en supprimant simplement le `await` mot clé à l’avant du `context.sync()` .</span><span class="sxs-lookup"><span data-stu-id="46fe6-126">It's worth asking whether the synchronize-inside-the-loop version would execute faster if the synchronizations ran concurrently, which could be done by simply removing the `await` keyword from the front of the `context.sync()`.</span></span> <span data-ttu-id="46fe6-127">Cela entraînerait le lancement de la synchronisation par le runtime, puis démarrera immédiatement l’itération suivante de la boucle sans attendre la fin de la synchronisation.</span><span class="sxs-lookup"><span data-stu-id="46fe6-127">This would cause the runtime to initiate the synchronization and then immediately start the next iteration of the loop without waiting for the synchronization to complete.</span></span> <span data-ttu-id="46fe6-128">Toutefois, cette solution n’est pas aussi intéressante que le fait `context.sync` de sortir entièrement de la boucle pour les raisons suivantes :</span><span class="sxs-lookup"><span data-stu-id="46fe6-128">However, this is not as good a solution as moving the `context.sync` out of the loop entirely for these reasons:</span></span>
>
> - <span data-ttu-id="46fe6-129">Tout comme les commandes d’un traitement par lots de synchronisation sont mises en file d’attente, les traitements par lots sont mis en file d’attente dans Office, mais Office ne prend pas en charge plus de 50 traitements par lots dans la file d’attente.</span><span class="sxs-lookup"><span data-stu-id="46fe6-129">Just as the commands in a synchronization batch job are queued, the batch jobs themselves are queued in Office, but Office supports no more than 50 batch jobs in the queue.</span></span> <span data-ttu-id="46fe6-130">Les autres déclenchent des erreurs.</span><span class="sxs-lookup"><span data-stu-id="46fe6-130">Any more triggers errors.</span></span> <span data-ttu-id="46fe6-131">Par conséquent, si une boucle comporte plus de 50 itérations, il est possible que la taille de la file d’attente soit dépassée.</span><span class="sxs-lookup"><span data-stu-id="46fe6-131">So, if there are more than 50 iterations in a loop, there is a chance that the queue size is exceeded.</span></span> <span data-ttu-id="46fe6-132">Plus le nombre d’itérations est élevé, plus le risque de se produire est élevé.</span><span class="sxs-lookup"><span data-stu-id="46fe6-132">The greater the number of iterations, the greater the chance of this happening.</span></span> 
> - <span data-ttu-id="46fe6-133">« Simultanément » ne signifie pas simultanément.</span><span class="sxs-lookup"><span data-stu-id="46fe6-133">"Concurrently" does not mean simultaneously.</span></span> <span data-ttu-id="46fe6-134">Il faudra toujours plus de temps pour exécuter plusieurs opérations de synchronisation plutôt que d’en exécuter une.</span><span class="sxs-lookup"><span data-stu-id="46fe6-134">It would still take longer to execute multiple synchronization operations than to execute one.</span></span>
> - <span data-ttu-id="46fe6-135">Il n’est pas garanti que les opérations simultanées se terminent dans l’ordre dans lequel elles ont démarré.</span><span class="sxs-lookup"><span data-stu-id="46fe6-135">Concurrent operations are not guaranteed to complete in the same order in which they started.</span></span> <span data-ttu-id="46fe6-136">Dans l’exemple précédent, l’ordre dans lequel le mot « the » est mis en surbrillance n’a pas d’importance, mais il est important que les éléments de la collection soient traités dans l’ordre.</span><span class="sxs-lookup"><span data-stu-id="46fe6-136">In the preceding example, it doesn't matter what order the  word "the" gets highlighted, but there are scenarios where it's important that the items in the collection be processed in order.</span></span>

## <a name="reading-values-from-the-document-with-the-split-loop-pattern"></a><span data-ttu-id="46fe6-137">Lecture de valeurs à partir du document avec le motif de boucle de fractionnement</span><span class="sxs-lookup"><span data-stu-id="46fe6-137">Reading values from the document with the split loop pattern</span></span>

<span data-ttu-id="46fe6-138">`context.sync`Il est plus difficile d’éviter les s à l’intérieur d’une boucle lorsque le code doit *lire* une propriété des éléments de la collection à mesure qu’il traite chacun d’eux.</span><span class="sxs-lookup"><span data-stu-id="46fe6-138">Avoiding `context.sync`s inside a loop becomes more challenging when the code must *read* a property of the collection items as it processes each one.</span></span> <span data-ttu-id="46fe6-139">Supposons que votre code doive itérer tous les contrôles de contenu d’un document Word et enregistrer le texte du premier paragraphe associé à chaque contrôle.</span><span class="sxs-lookup"><span data-stu-id="46fe6-139">Suppose your code needs to iterate all the content controls in a Word document and log the text of the first paragraph associated with each control.</span></span> <span data-ttu-id="46fe6-140">Vos instincts de programmation peuvent vous amener à parcourir les contrôles, charger la `text` propriété de chaque paragraphe (premier), appeler `context.sync` pour remplir l’objet de paragraphe de proxy avec le texte du document, puis le consigner.</span><span class="sxs-lookup"><span data-stu-id="46fe6-140">Your programming instincts might lead you to loop over the controls, load the `text` property of each (first) paragraph, call `context.sync` to populate the proxy paragraph object with the text from the document, and then log it.</span></span> <span data-ttu-id="46fe6-141">Voici un exemple.</span><span class="sxs-lookup"><span data-stu-id="46fe6-141">The following is an example.</span></span>

```javascript
Word.run(async (context) => {
    const contentControls = context.document.contentControls.load('items');
    await context.sync();

    for (let i = 0; i < contentControls.items.length; i++) {
      const paragraph = contentControls.items[i].getRange('Whole').paragraphs.getFirst();
      paragraph.load('text');
      await context.sync();
      console.log(paragraph.text);
    }
});
```

<span data-ttu-id="46fe6-142">Dans ce scénario, pour éviter d’avoir une `context.sync` boucle, vous devez utiliser un modèle appelé modèle de **boucle de fractionnement** .</span><span class="sxs-lookup"><span data-stu-id="46fe6-142">In this scenario, to avoid having a `context.sync` in a loop, you should use a pattern we call the **split loop** pattern.</span></span> <span data-ttu-id="46fe6-143">Examinons un exemple concret du modèle avant d’obtenir une description formelle.</span><span class="sxs-lookup"><span data-stu-id="46fe6-143">Let's see a concrete example of the pattern before we get to a formal description of it.</span></span> <span data-ttu-id="46fe6-144">Voici comment le modèle de boucle de fractionnement peut être appliqué à l’extrait de code précédent.</span><span class="sxs-lookup"><span data-stu-id="46fe6-144">Here's how the split loop pattern can be applied to the preceding code snippet.</span></span> <span data-ttu-id="46fe6-145">Tenez compte des informations suivantes à propos de ce code :</span><span class="sxs-lookup"><span data-stu-id="46fe6-145">Note the following about this code:</span></span>

- <span data-ttu-id="46fe6-146">Il y a maintenant deux boucles et l' `context.sync` intervient entre elles, de sorte qu’il n’y a pas `context.sync` à l’intérieur de l’une ou l’autre boucle.</span><span class="sxs-lookup"><span data-stu-id="46fe6-146">There are now two loops and the `context.sync` comes between them, so there's no `context.sync` inside either loop.</span></span>
- <span data-ttu-id="46fe6-147">La première boucle parcourt les éléments de l’objet de collection et charge la `text` propriété tout comme la boucle d’origine, mais la première boucle ne peut pas consigner le texte du paragraphe, car elle ne contient plus de `context.sync` pour remplir la `text` propriété de l' `paragraph` objet proxy.</span><span class="sxs-lookup"><span data-stu-id="46fe6-147">The first loop iterates through the items in the collection object and loads the `text` property just as the original loop did, but the first loop cannot log the paragraph text because it no longer contains a `context.sync` to populate the `text` property of the `paragraph` proxy object.</span></span> <span data-ttu-id="46fe6-148">Au lieu de cela, il ajoute l' `paragraph` objet à un tableau.</span><span class="sxs-lookup"><span data-stu-id="46fe6-148">Instead, it adds the `paragraph` object to an array.</span></span>
- <span data-ttu-id="46fe6-149">La deuxième boucle se répète dans le tableau qui a été créé par la première boucle et enregistre l' `text` `paragraph` élément.</span><span class="sxs-lookup"><span data-stu-id="46fe6-149">The second loop iterates through the array that was created by the first loop, and logs the `text` of each `paragraph` item.</span></span> <span data-ttu-id="46fe6-150">Cela est possible, car les `context.sync` deux boucles ont rempli toutes les `text` Propriétés.</span><span class="sxs-lookup"><span data-stu-id="46fe6-150">This is possible because the `context.sync` that came between the two loops populated all the `text` properties.</span></span>

```javascript
Word.run(async (context) => {
    const contentControls = context.document.contentControls.load("items");
    await context.sync();

    const firstParagraphsOfCCs = [];
    for (let i = 0; i < contentControls.items.length; i++) {
      const paragraph = contentControls.items[i].getRange('Whole').paragraphs.getFirst();
      paragraph.load('text');
      firstParagraphsOfCCs.push(paragraph);
    }

    await context.sync();

    for (let i = 0; i < firstParagraphsOfCCs.length; i++) {
      console.log(firstParagraphsOfCCs[i].text);
    }
});
```

<span data-ttu-id="46fe6-151">L’exemple précédent suggère la procédure suivante pour activer une boucle qui contient un `context.sync` dans le motif de boucle de fractionnement :</span><span class="sxs-lookup"><span data-stu-id="46fe6-151">The preceding example suggests the following procedure for turning a loop that contains a `context.sync` into the split loop pattern:</span></span> 

1. <span data-ttu-id="46fe6-152">Remplacez la boucle par deux boucles.</span><span class="sxs-lookup"><span data-stu-id="46fe6-152">Replace the loop with two loops.</span></span>
2. <span data-ttu-id="46fe6-153">Créer une première boucle pour effectuer une itération sur la collection et ajouter chaque élément à un tableau tout en chargeant également toute propriété de l’élément que votre code doit lire.</span><span class="sxs-lookup"><span data-stu-id="46fe6-153">Create a first loop to iterate over the collection and add each item to an array while also loading any property of the item that your code needs to read.</span></span> 
3. <span data-ttu-id="46fe6-154">À la suite de la première boucle, appelez `context.sync` pour remplir les objets proxy avec n’importe quelle propriété chargée.</span><span class="sxs-lookup"><span data-stu-id="46fe6-154">Following the first loop, call `context.sync` to populate the proxy objects with any loaded properties.</span></span> 
4. <span data-ttu-id="46fe6-155">Suivez la `context.sync` boucle avec une seconde pour effectuer une itération sur le tableau créé dans la première boucle et lire les propriétés chargées.</span><span class="sxs-lookup"><span data-stu-id="46fe6-155">Follow the `context.sync` with a second loop to iterate over the array created in the first loop and read the loaded properties.</span></span>

## <a name="processing-objects-in-the-document-with-the-correlated-objects-pattern"></a><span data-ttu-id="46fe6-156">Traitement des objets dans le document avec le modèle d’objets corrélés</span><span class="sxs-lookup"><span data-stu-id="46fe6-156">Processing objects in the document with the correlated objects pattern</span></span>

<span data-ttu-id="46fe6-157">Examinons un scénario plus complexe où le traitement des éléments dans la collection nécessite des données qui ne se trouvent pas dans les éléments eux-mêmes.</span><span class="sxs-lookup"><span data-stu-id="46fe6-157">Let's consider a more complex scenario where processing the items in the collection requires data that isn't in the items themselves.</span></span> <span data-ttu-id="46fe6-158">Le scénario prévisionne un complément Word qui opère sur des documents créés à partir d’un modèle avec du texte réutilisable.</span><span class="sxs-lookup"><span data-stu-id="46fe6-158">The scenario envisions a Word add-in that operates on documents created from a template with some boilerplate text.</span></span> <span data-ttu-id="46fe6-159">Éparpillés dans le texte sont une ou plusieurs instances des chaînes d’espace réservé suivantes : « {Coordinator} », « {adjoint} » et « {Manager} ».</span><span class="sxs-lookup"><span data-stu-id="46fe6-159">Scattered in the text are one or more instances of the following placeholder strings: "{Coordinator}", "{Deputy}", and "{Manager}".</span></span> <span data-ttu-id="46fe6-160">Le complément remplace chaque espace réservé par le nom de la personne.</span><span class="sxs-lookup"><span data-stu-id="46fe6-160">The add-in replaces each placeholder with some person's name.</span></span> <span data-ttu-id="46fe6-161">L’interface utilisateur du complément n’est pas importante dans cet article.</span><span class="sxs-lookup"><span data-stu-id="46fe6-161">The UI of the add-in is not important to this article.</span></span> <span data-ttu-id="46fe6-162">Par exemple, il peut contenir un volet de tâches comportant trois zones de texte, chacune étiquetée avec l’un des espaces réservés.</span><span class="sxs-lookup"><span data-stu-id="46fe6-162">For example, it could have a task pane with three text boxes, each labeled with one of the placeholders.</span></span> <span data-ttu-id="46fe6-163">L’utilisateur entre un nom dans chaque zone de texte et appuie sur un bouton **remplacer** .</span><span class="sxs-lookup"><span data-stu-id="46fe6-163">The user enters a name in each text box and then presses a **Replace** button.</span></span> <span data-ttu-id="46fe6-164">Le gestionnaire du bouton crée un tableau qui mappe les noms aux espaces réservés, puis remplace chaque espace réservé par le nom attribué.</span><span class="sxs-lookup"><span data-stu-id="46fe6-164">The handler for the button creates an array that maps the names to the placeholders, and then replaces each placeholder with the assigned name.</span></span> 

<span data-ttu-id="46fe6-165">Vous n’avez pas besoin de produire réellement un complément avec cette interface utilisateur pour tester le code.</span><span class="sxs-lookup"><span data-stu-id="46fe6-165">You don't need to actually produce an add-in with this UI to experiment with the code.</span></span> <span data-ttu-id="46fe6-166">Vous pouvez utiliser l' [outil script Lab](../overview/explore-with-script-lab.md) pour prototyper le code important.</span><span class="sxs-lookup"><span data-stu-id="46fe6-166">You can use the [Script Lab tool](../overview/explore-with-script-lab.md) to prototype the important code.</span></span> <span data-ttu-id="46fe6-167">Utilisez l’instruction d’affectation suivante pour créer le tableau de mappage.</span><span class="sxs-lookup"><span data-stu-id="46fe6-167">Use the following assignment statement to create the mapping array.</span></span>

```javascript
const jobMapping = [
        { job: "{Coordinator}", person: "Sally" },
        { job: "{Deputy}", person: "Bob" },
        { job: "{Manager}", person: "Kim" }
    ];
```

<span data-ttu-id="46fe6-168">Le code suivant montre comment remplacer chaque espace réservé par son nom attribué si vous avez utilisé `context.sync` à l’intérieur de boucles.</span><span class="sxs-lookup"><span data-stu-id="46fe6-168">The following code shows how you might replace each placeholder with its assigned name if you used `context.sync` inside loops.</span></span>

```javascript
Word.run(async (context) => {

    for (let i = 0; i < jobMapping.length; i++) {
      let options = Word.SearchOptions.newObject(context);
      options.matchWildCards = false;
      let searchResults = context.document.body.search(jobMapping[i].job, options);
      searchResults.load('items');

      await context.sync(); 

      for (let j = 0; j < searchResults.items.length; j++) {
        searchResults.items[j].insertText(jobMapping[i].person, Word.InsertLocation.replace);

        await context.sync();
      }
    }
});
```

<span data-ttu-id="46fe6-169">Dans le code précédent, il existe une boucle externe et une boucle interne.</span><span class="sxs-lookup"><span data-stu-id="46fe6-169">In the preceding code, there is an outer and an inner loop.</span></span> <span data-ttu-id="46fe6-170">Chacun d’eux contient un `context.sync` .</span><span class="sxs-lookup"><span data-stu-id="46fe6-170">Each of them contains a `context.sync`.</span></span> <span data-ttu-id="46fe6-171">En fonction du tout premier extrait de code de cet article, vous verrez probablement que le `context.sync` dans la boucle interne peut simplement être déplacé après la boucle interne.</span><span class="sxs-lookup"><span data-stu-id="46fe6-171">Based on the very first code snippet in this article, you probably see that the `context.sync` in the inner loop can simply be moved after the inner loop.</span></span> <span data-ttu-id="46fe6-172">Mais cela laisserait toujours le code avec un `context.sync` (deux d’entre eux) dans la boucle externe.</span><span class="sxs-lookup"><span data-stu-id="46fe6-172">But that would still leave the code with a `context.sync` (two of them actually) in the outer loop.</span></span> <span data-ttu-id="46fe6-173">Le code suivant montre comment vous pouvez supprimer `context.sync` des boucles.</span><span class="sxs-lookup"><span data-stu-id="46fe6-173">The following code shows how you can remove `context.sync` from the loops.</span></span> <span data-ttu-id="46fe6-174">Nous abordons le code ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="46fe6-174">We discuss the code below.</span></span>

```javascript
Word.run(async (context) => {

    const allSearchResults = [];
    for (let i = 0; i < jobMapping.length; i++) {
      let options = Word.SearchOptions.newObject(context);
      options.matchWildCards = false;
      let searchResults = context.document.body.search(jobMapping[i].job, options);
      searchResults.load('items');
      let correlatedSearchResult = {
        rangesMatchingJob: searchResults,
        personAssignedToJob: jobMapping[i].person
      }
      allSearchResults.push(correlatedSearchResult);
    }

    await context.sync()

    for (let i = 0; i < allSearchResults.length; i++) {
      let correlatedObject = allSearchResults[i];

      for (let j = 0; j < correlatedObject.rangesMatchingJob.items.length; j++) {        
        let targetRange = correlatedObject.rangesMatchingJob.items[j];
        let name = correlatedObject.personAssignedToJob;
        targetRange.insertText(name, Word.InsertLocation.replace);
      }
    }

    await context.sync();
});
```

<span data-ttu-id="46fe6-175">Remarque le code utilise le modèle de boucle de fractionnement :</span><span class="sxs-lookup"><span data-stu-id="46fe6-175">Note the code uses the split loop pattern:</span></span>

- <span data-ttu-id="46fe6-176">La boucle externe de l’exemple précédent a été divisée en deux.</span><span class="sxs-lookup"><span data-stu-id="46fe6-176">The outer loop from the preceding example has been split into two.</span></span> <span data-ttu-id="46fe6-177">(La deuxième boucle possède une boucle interne, qui est attendue car le code se répète sur un ensemble de travaux (ou espaces réservés) et, dans cette définition, elle se répète sur les plages correspondantes.)</span><span class="sxs-lookup"><span data-stu-id="46fe6-177">(The second loop has an inner loop, which is expected because the code is iterating over a set of jobs (or placeholders) and within that set it is iterating over the matching ranges.)</span></span>
- <span data-ttu-id="46fe6-178">Il y a une `context.sync` boucle après chaque boucle principale, mais pas `context.sync` à l’intérieur d’une boucle.</span><span class="sxs-lookup"><span data-stu-id="46fe6-178">There is a `context.sync` after each major loop, but no `context.sync` inside any loop.</span></span> 
- <span data-ttu-id="46fe6-179">La deuxième boucle majeure effectue une itération dans un tableau créé dans la première boucle.</span><span class="sxs-lookup"><span data-stu-id="46fe6-179">The second major loop iterates through an array that is created in the first loop.</span></span>

<span data-ttu-id="46fe6-180">Toutefois, le tableau créé dans la première boucle ne contient *pas* uniquement un objet Office comme première boucle dans la section [Reading values from the document with the Split Loop pattern](#reading-values-from-the-document-with-the-split-loop-pattern).</span><span class="sxs-lookup"><span data-stu-id="46fe6-180">But the array created in the first loop does *not* contain only an Office object as the first loop did in the section [Reading values from the document with the split loop pattern](#reading-values-from-the-document-with-the-split-loop-pattern).</span></span> <span data-ttu-id="46fe6-181">Cela est dû au fait que certaines des informations nécessaires au traitement des objets de plage Word ne se trouvent pas dans les objets Range eux-mêmes, mais qu’elles proviennent du `jobMapping` tableau.</span><span class="sxs-lookup"><span data-stu-id="46fe6-181">This is because some of the information needed to process the Word Range objects is not in the Range objects themselves but instead comes from the `jobMapping` array.</span></span> 

<span data-ttu-id="46fe6-182">Par conséquent, les objets dans le tableau créé dans la première boucle sont des objets personnalisés ayant deux propriétés.</span><span class="sxs-lookup"><span data-stu-id="46fe6-182">So, the objects in the array created in the first loop are custom objects that have two properties.</span></span> <span data-ttu-id="46fe6-183">Le premier est un tableau de plages de mots qui correspondent à une fonction spécifique (c’est-à-dire une chaîne d’espace réservé) et le deuxième est une chaîne qui fournit le nom de la personne affectée au travail.</span><span class="sxs-lookup"><span data-stu-id="46fe6-183">The first is an array of Word Ranges that match a specific job title (that is, a placeholder string) and the second is a string that provides the name of the person assigned to the job.</span></span> <span data-ttu-id="46fe6-184">Cela rend la boucle finale facile à écrire et facile à lire, car toutes les informations nécessaires au traitement d’une plage donnée sont contenues dans le même objet personnalisé qui contient la plage.</span><span class="sxs-lookup"><span data-stu-id="46fe6-184">This makes the final loop easy to write and easy to read because all of the information needed to process a given range is contained in the same custom object that contains the range.</span></span> <span data-ttu-id="46fe6-185">Le nom qui doit remplacer _ **correlatedObject**. rangesMatchingJob. Items [j]_ est l’autre propriété du même objet : _ **correlatedObject**. personAssignedToJob_.</span><span class="sxs-lookup"><span data-stu-id="46fe6-185">The name that should replace _**correlatedObject**.rangesMatchingJob.items[j]_ is the other property of the same object: _**correlatedObject**.personAssignedToJob_.</span></span> 

<span data-ttu-id="46fe6-186">Nous appelons cette variante du modèle d' **objets corrélé** .</span><span class="sxs-lookup"><span data-stu-id="46fe6-186">We call this variation of the split loop pattern the **correlated objects** pattern.</span></span> <span data-ttu-id="46fe6-187">L’idée générale est que la première boucle crée un tableau d’objets personnalisés.</span><span class="sxs-lookup"><span data-stu-id="46fe6-187">The general idea is that the first loop creates an array of custom objects.</span></span> <span data-ttu-id="46fe6-188">Chaque objet possède une propriété dont la valeur est l’un des éléments d’un objet de collection Office (ou un tableau de ces éléments).</span><span class="sxs-lookup"><span data-stu-id="46fe6-188">Each object has a property whose value is one of the items in an Office collection object (or an array of such items).</span></span> <span data-ttu-id="46fe6-189">L’objet personnalisé possède d’autres propriétés, chacune fournissant les informations nécessaires pour traiter les objets Office dans la boucle finale.</span><span class="sxs-lookup"><span data-stu-id="46fe6-189">The custom object has other properties, each of which provides information needed to process the Office objects in the final loop.</span></span> <span data-ttu-id="46fe6-190">Voir la section [autres exemples de ces modèles](#other-examples-of-these-patterns) pour un lien vers un exemple dans lequel l’objet de corrélation personnalisé comporte plus de deux propriétés.</span><span class="sxs-lookup"><span data-stu-id="46fe6-190">See the section [Other examples of these patterns](#other-examples-of-these-patterns) for a link to an example where the custom correlating object has more than two properties.</span></span>

<span data-ttu-id="46fe6-191">Une autre restriction : parfois, il faut plus d’une boucle pour créer le tableau des objets corrélés personnalisés.</span><span class="sxs-lookup"><span data-stu-id="46fe6-191">One further caveat: sometimes it takes more than one loop just to create the array of custom correlating objects.</span></span> <span data-ttu-id="46fe6-192">Cela peut se produire si vous avez besoin de lire une propriété de chaque membre d’un objet de collection Office uniquement pour collecter des informations qui seront utilisées pour traiter un autre objet de collection.</span><span class="sxs-lookup"><span data-stu-id="46fe6-192">This can happen if you need to read a property of each member of one Office collection object just to gather information that will be used to process another collection object.</span></span> <span data-ttu-id="46fe6-193">(Par exemple, votre code doit lire les titres de toutes les colonnes d’un tableau Excel, car votre complément va appliquer un format numérique aux cellules de certaines colonnes en fonction du titre de cette colonne.) Toutefois, vous pouvez toujours conserver les `context.sync` s entre les boucles, plutôt que dans une boucle.</span><span class="sxs-lookup"><span data-stu-id="46fe6-193">(For example, your code needs to read the titles of all the columns in an Excel table because your add-in is going to apply a number format to the cells of some columns based on that column's title.) But you can always keep the `context.sync`s between the loops, rather than in a loop.</span></span> <span data-ttu-id="46fe6-194">Consultez la section [autres exemples de ces modèles](#other-examples-of-these-patterns) pour obtenir un exemple.</span><span class="sxs-lookup"><span data-stu-id="46fe6-194">See the section [Other examples of these patterns](#other-examples-of-these-patterns) for an example.</span></span>

## <a name="other-examples-of-these-patterns"></a><span data-ttu-id="46fe6-195">Autres exemples de ces modèles</span><span class="sxs-lookup"><span data-stu-id="46fe6-195">Other examples of these patterns</span></span>

- <span data-ttu-id="46fe6-196">Pour un exemple très simple pour Excel qui utilise des `Array.forEach` boucles, consultez la question relative à la réponse acceptée à ce débordement de pile : [est-il possible de prendre en file d’attente plusieurs Context. Load avant Context. Sync ?](https://stackoverflow.com/questions/44459604/is-it-possible-to-queue-more-than-one-context-load-before-context-sync)</span><span class="sxs-lookup"><span data-stu-id="46fe6-196">For a very simple example for Excel that uses `Array.forEach` loops, see the accepted answer to this Stack Overflow question: [Is it possible to queue more than one context.load before context.sync?](https://stackoverflow.com/questions/44459604/is-it-possible-to-queue-more-than-one-context-load-before-context-sync)</span></span>
- <span data-ttu-id="46fe6-197">Pour un exemple simple pour Word qui utilise des `Array.forEach` boucles et n’utilise pas de `async` / `await` syntaxe, voir la réponse acceptée à cette question de dépassement de pile : [itération sur tous les paragraphes avec des contrôles de contenu avec l’API JavaScript pour Office](https://stackoverflow.com/questions/58422113/iterating-over-all-paragraphs-with-content-controls-with-office-javascript-api).</span><span class="sxs-lookup"><span data-stu-id="46fe6-197">For a simple example for Word that uses `Array.forEach` loops and doesn't use `async`/`await` syntax, see the accepted answer to this Stack Overflow question: [Iterating over all paragraphs with content controls with Office JavaScript API](https://stackoverflow.com/questions/58422113/iterating-over-all-paragraphs-with-content-controls-with-office-javascript-api).</span></span>
- <span data-ttu-id="46fe6-198">Pour obtenir un exemple pour Word écrit en écriture manuscrite, consultez l’exemple de [Vérificateur de style Angular2 de complément Word](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker), en particulier le fichier [Word. document. service. TS](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker/blob/master/app/services/word-document/word.document.service.ts).</span><span class="sxs-lookup"><span data-stu-id="46fe6-198">For an example for Word that is written in TypeScript, see the sample [Word Add-in Angular2 Style Checker](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker), especially the file [word.document.service.ts](https://github.com/OfficeDev/Word-Add-in-Angular2-StyleChecker/blob/master/app/services/word-document/word.document.service.ts).</span></span> <span data-ttu-id="46fe6-199">Elle comporte une combinaison de `for` et de `Array.forEach` boucles.</span><span class="sxs-lookup"><span data-stu-id="46fe6-199">It has a mixture of `for` and `Array.forEach` loops.</span></span>
- <span data-ttu-id="46fe6-200">Pour un exemple de mot avancé, [importez-le dans](https://gist.github.com/9c5a803e52480ec7f00bb3224292e0ab) l' [outil script Lab](../overview/explore-with-script-lab.md).</span><span class="sxs-lookup"><span data-stu-id="46fe6-200">For an advanced Word sample, import [this gist](https://gist.github.com/9c5a803e52480ec7f00bb3224292e0ab) into the [Script Lab tool](../overview/explore-with-script-lab.md).</span></span> <span data-ttu-id="46fe6-201">Pour le contexte dans l’utilisation du fichier d’aide à la pile, consultez la réponse acceptée sur le document de la question de débordement de pile [non synchronisé après le texte de remplacement](https://stackoverflow.com/questions/48227941/document-not-in-sync-after-replace-text).</span><span class="sxs-lookup"><span data-stu-id="46fe6-201">For context in using the gist, see the accepted answer to the Stack Overflow question [Document not in sync after replace text](https://stackoverflow.com/questions/48227941/document-not-in-sync-after-replace-text).</span></span> <span data-ttu-id="46fe6-202">Cet exemple crée un type d’objet corrélé personnalisé qui a trois propriétés.</span><span class="sxs-lookup"><span data-stu-id="46fe6-202">This sample creates a custom correlating object type that has three properties.</span></span> <span data-ttu-id="46fe6-203">Il utilise un total de trois boucles pour construire le tableau des objets corrélés, et deux boucles supplémentaires pour effectuer le traitement final.</span><span class="sxs-lookup"><span data-stu-id="46fe6-203">It uses a total of three loops to construct the array of correlated objects, and two more loops to do the final processing.</span></span> <span data-ttu-id="46fe6-204">Il existe un mélange de `for` boucles et de `Array.forEach` boucles.</span><span class="sxs-lookup"><span data-stu-id="46fe6-204">There are a mixture of `for` and `Array.forEach` loops.</span></span>
- <span data-ttu-id="46fe6-205">Bien que ce ne soit pas seulement un exemple des modèles de boucle de fractionnement ou d’objets corrélés, il existe un exemple Excel avancé qui montre comment convertir un ensemble de valeurs de cellule en d’autres devises avec un seul `context.sync` .</span><span class="sxs-lookup"><span data-stu-id="46fe6-205">Although not strictly an example of the split loop or correlated objects patterns, there is an advanced Excel sample that shows how to convert a set of cell values to other currencies with just a single `context.sync`.</span></span> <span data-ttu-id="46fe6-206">Pour l’essayer, ouvrez l' [outil script Lab](../overview/explore-with-script-lab.md) et accédez à l’exemple **convertisseur de devise** .</span><span class="sxs-lookup"><span data-stu-id="46fe6-206">To try it, open the [Script Lab tool](../overview/explore-with-script-lab.md) and navigate to the **Currency Converter** sample.</span></span> 

## <a name="when-should-you-not-use-the-patterns-in-this-article"></a><span data-ttu-id="46fe6-207">Quand *devez-vous utiliser* les modèles de cet article ?</span><span class="sxs-lookup"><span data-stu-id="46fe6-207">When should you *not* use the patterns in this article?</span></span>

<span data-ttu-id="46fe6-208">Excel ne peut pas lire plus de 5 Mo de données dans un appel de `context.sync` .</span><span class="sxs-lookup"><span data-stu-id="46fe6-208">Excel cannot read more than 5 MB of data in a given call of `context.sync`.</span></span> <span data-ttu-id="46fe6-209">Si cette limite est dépassée, une erreur est générée.</span><span class="sxs-lookup"><span data-stu-id="46fe6-209">If this limit is exceeded, an error is thrown.</span></span> <span data-ttu-id="46fe6-210">(Pour plus d’informations, consultez la rubrique [limites de transfert de données Excel](../develop/common-coding-issues.md#excel-data-transfer-limits).) Il est très rare que cette limite soit proche, mais si cela peut se produire avec votre complément, votre code *ne doit pas* charger toutes les données dans une seule boucle et suivre la boucle avec un `context.sync` .</span><span class="sxs-lookup"><span data-stu-id="46fe6-210">(For more information, see [Excel data transfer limits](../develop/common-coding-issues.md#excel-data-transfer-limits).) It is very rare that this limit is approached, but if there's a chance that this will happen with your add-in, then your code should *not* load all the data in a single loop and follow the loop with a `context.sync`.</span></span> <span data-ttu-id="46fe6-211">Toutefois, vous devez toujours éviter d’avoir une `context.sync` boucle dans chaque itération d’une boucle sur un objet de collection.</span><span class="sxs-lookup"><span data-stu-id="46fe6-211">But you still should avoid having a `context.sync` in every iteration of a loop over a collection object.</span></span> <span data-ttu-id="46fe6-212">Au lieu de cela, définissez des sous-ensembles des éléments de la collection et faites une boucle sur chaque sous-ensemble, avec un `context.sync` entre les boucles.</span><span class="sxs-lookup"><span data-stu-id="46fe6-212">Instead, define subsets of the items in the collection and loop over each subset in turn, with a `context.sync` between the loops.</span></span> <span data-ttu-id="46fe6-213">Vous pouvez la structurer avec une boucle externe qui itère sur les sous-ensembles et contient le `context.sync` dans chacune de ces itérations externes.</span><span class="sxs-lookup"><span data-stu-id="46fe6-213">You could structure this with an outer loop that iterates over the subsets and contains the `context.sync` in each of these outer iterations.</span></span>
